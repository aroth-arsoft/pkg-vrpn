--- a/vrpn_Contour.C
+++ b/vrpn_Contour.C
@@ -14,6 +14,7 @@
 // USB vendor and product IDs for the models we support
 static const vrpn_uint16 CONTOUR_VENDOR = 0x0b33;
 static const vrpn_uint16 CONTOUR_SHUTTLEXPRESS = 0x0020;
+static const vrpn_uint16 CONTOUR_SHUTTLEPRO = 0x0010;
 static const vrpn_uint16 CONTOUR_SHUTTLEPROV2 = 0x0030;
 
 static void normalize_axis(const unsigned int value, const short deadzone, const vrpn_float64 scale, vrpn_float64& channel) {
@@ -204,6 +205,154 @@
 	}
 }
 
+vrpn_Contour_ShuttlePRO::vrpn_Contour_ShuttlePRO(const char *name, vrpn_Connection *c)
+    : vrpn_Contour(_filter = new vrpn_HidProductAcceptor(CONTOUR_VENDOR, CONTOUR_SHUTTLEPRO), name, c, CONTOUR_VENDOR, CONTOUR_SHUTTLEPRO)
+	, vrpn_Analog(name, c)
+	, vrpn_Button_Filter(name, c)
+	, vrpn_Dial(name, c)
+{
+	vrpn_Analog::num_channel = 2;
+	vrpn_Dial::num_dials = 1;
+	vrpn_Button::num_buttons = 15;
+
+	// Initialize the state of all the analogs, buttons, and dials
+	_lastDial = 0;
+	memset(buttons, 0, sizeof(buttons));
+	memset(lastbuttons, 0, sizeof(lastbuttons));
+	memset(channel, 0, sizeof(channel));
+	memset(last, 0, sizeof(last));
+}
+
+void vrpn_Contour_ShuttlePRO::mainloop(void)
+{
+	update();
+	server_mainloop();
+	struct timeval current_time;
+	vrpn_gettimeofday(&current_time, NULL);
+	if (vrpn_TimevalDuration(current_time, _timestamp) > POLL_INTERVAL) {
+		_timestamp = current_time;
+		report_changes();
+
+		if (vrpn_Analog::num_channel > 0)
+		{
+			vrpn_Analog::server_mainloop();
+		}
+		if (vrpn_Button::num_buttons > 0)
+		{
+			vrpn_Button::server_mainloop();
+		}
+		if (vrpn_Dial::num_dials > 0)
+		{
+			vrpn_Dial::server_mainloop();
+		}
+	}
+}
+
+void vrpn_Contour_ShuttlePRO::report(vrpn_uint32 class_of_service)
+{
+	if (vrpn_Analog::num_channel > 0)
+	{
+		vrpn_Analog::timestamp = _timestamp;
+	}
+	if (vrpn_Button::num_buttons > 0)
+	{
+		vrpn_Button::timestamp = _timestamp;
+	}
+	if (vrpn_Dial::num_dials > 0)
+	{
+		vrpn_Dial::timestamp = _timestamp;
+	}
+
+	if (vrpn_Analog::num_channel > 0)
+	{
+		vrpn_Analog::report(class_of_service);
+	}
+	if (vrpn_Button::num_buttons > 0)
+	{
+		vrpn_Button::report_changes();
+	}
+	if (vrpn_Dial::num_dials > 0)
+	{
+		vrpn_Dial::report();
+	}
+}
+
+void vrpn_Contour_ShuttlePRO::report_changes(vrpn_uint32 class_of_service)
+{
+	if (vrpn_Analog::num_channel > 0)
+	{
+		vrpn_Analog::timestamp = _timestamp;
+	}
+	if (vrpn_Button::num_buttons > 0)
+	{
+		vrpn_Button::timestamp = _timestamp;
+	}
+	if (vrpn_Dial::num_dials > 0)
+	{
+		vrpn_Dial::timestamp = _timestamp;
+	}
+
+	if (vrpn_Analog::num_channel > 0)
+	{
+		vrpn_Analog::report_changes(class_of_service);
+	}
+	if (vrpn_Button::num_buttons > 0)
+	{
+		vrpn_Button::report_changes();
+	}
+	if (vrpn_Dial::num_dials > 0)
+	{
+		vrpn_Dial::report_changes();
+	}
+}
+
+void vrpn_Contour_ShuttlePRO::decodePacket(size_t bytes, vrpn_uint8 *buffer)
+{
+	// Print the report so we can figure out what is going on.
+/*	for (size_t i = 0; i < bytes; i++) {
+	printf("%02x ", buffer[i]);
+	}
+	printf("\n");
+	return; */
+
+	// Decode all full reports, each of which is 5 bytes long.
+	// Because there is only one type of report, the initial "0" report-type
+	// byte is removed by the HIDAPI driver.
+	if (bytes == 5) {
+		if (!_gotDial) {
+			_gotDial = true;
+		}
+		else {
+			dials[0] = static_cast<vrpn_int8>(buffer[1] - _lastDial) / 10.0;
+		}
+		_lastDial = buffer[1];
+
+		// analog (1st byte): 0 center, 1..7 right, -1..-7 left
+		normalize_axis((unsigned int)((static_cast<float>(static_cast<vrpn_int8>(buffer[0])) * 128.0f / 7.0f) + 128.0f), 0, 1.0f, channel[0]);
+		// Second analog integrates the dial value.
+		channel[1] += dials[0];
+
+		// Top row of four buttons, from left to right: index[bit]
+		//   3[0], 3[1], 3[2], 3[3]
+		// Second row of 5 buttons, from left to right:
+		//   3[4], 3[5], 3[6], 3[7], 4[0]
+		// Four lower buttons, from left to right and then down to next row:
+		//   4[1], 4[2], 4[3], 4[4]
+		// Two black buttons, from left to right:
+		//   4[5], 4[6]
+		for (int btn = 0; btn <= 15; btn++) {
+			vrpn_uint8 *offset, mask;
+
+			offset = buffer + btn / 8 + 3;
+			mask = static_cast<vrpn_uint8>(1 << (btn % 8));
+
+			buttons[btn] = (*offset & mask) != 0;
+		}
+	}
+	else {
+		fprintf(stderr, "vrpn_Contour_ShuttlePROv2: Found a corrupted report; # total bytes = %u\n", static_cast<unsigned>(bytes));
+	}
+}
 
 vrpn_Contour_ShuttlePROv2::vrpn_Contour_ShuttlePROv2(const char *name, vrpn_Connection *c)
     : vrpn_Contour(_filter = new vrpn_HidProductAcceptor(CONTOUR_VENDOR, CONTOUR_SHUTTLEPROV2), name, c, CONTOUR_VENDOR, CONTOUR_SHUTTLEPROV2)
--- a/vrpn_Contour.h
+++ b/vrpn_Contour.h
@@ -21,7 +21,7 @@
 // All models expose Buttons for the keys on the device.
 //
 
-class vrpn_Contour: public vrpn_BaseClass, protected vrpn_HidInterface {
+class VRPN_API vrpn_Contour: public vrpn_BaseClass, protected vrpn_HidInterface {
 public:
   vrpn_Contour(vrpn_HidAcceptor *filter, const char *name, vrpn_Connection *c = 0,
       vrpn_uint16 vendor = 0, vrpn_uint16 product = 0);
@@ -52,7 +52,7 @@
   vrpn_uint8 _lastDial;
 };
 
-class vrpn_Contour_ShuttleXpress: protected vrpn_Contour, public vrpn_Analog, public vrpn_Button_Filter, public vrpn_Dial {
+class VRPN_API vrpn_Contour_ShuttleXpress: protected vrpn_Contour, public vrpn_Analog, public vrpn_Button_Filter, public vrpn_Dial {
 public:
   vrpn_Contour_ShuttleXpress(const char *name, vrpn_Connection *c = 0);
   virtual ~vrpn_Contour_ShuttleXpress(void) {};
@@ -68,7 +68,26 @@
   void decodePacket(size_t bytes, vrpn_uint8 *buffer);
 };
 
-class vrpn_Contour_ShuttlePROv2 : protected vrpn_Contour, public vrpn_Analog, public vrpn_Button_Filter, public vrpn_Dial {
+class VRPN_API vrpn_Contour_ShuttlePRO : protected vrpn_Contour, public vrpn_Analog, public vrpn_Button_Filter, public vrpn_Dial {
+public:
+	vrpn_Contour_ShuttlePRO(const char *name, vrpn_Connection *c = 0);
+	virtual ~vrpn_Contour_ShuttlePRO(void) {};
+
+	virtual void mainloop(void);
+
+protected:
+	// Send report iff changed
+	void report_changes(vrpn_uint32 class_of_service = vrpn_CONNECTION_LOW_LATENCY);
+	// Send report whether or not changed
+	void report(vrpn_uint32 class_of_service = vrpn_CONNECTION_LOW_LATENCY);
+
+	void decodePacket(size_t bytes, vrpn_uint8 *buffer);
+
+	// Previous dial value, used to determine delta to send when it changes.
+	vrpn_uint8 _lastDial;
+};
+
+class VRPN_API vrpn_Contour_ShuttlePROv2 : protected vrpn_Contour, public vrpn_Analog, public vrpn_Button_Filter, public vrpn_Dial {
 public:
 	vrpn_Contour_ShuttlePROv2(const char *name, vrpn_Connection *c = 0);
 	virtual ~vrpn_Contour_ShuttlePROv2(void) {};
@@ -91,5 +110,6 @@
 #else
 class VRPN_API vrpn_Contour;
 class VRPN_API vrpn_Contour_ShuttleXpress;
+class VRPN_API vrpn_Contour_ShuttlePRO;
 class VRPN_API vrpn_Contour_ShuttlePROv2;
 #endif
